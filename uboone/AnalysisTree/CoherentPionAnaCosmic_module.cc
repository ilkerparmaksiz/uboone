////////////////////////////////////////////////////////////////////////
// Class:       CoherentPionAnaCosmic
// Module Type: analyzer
// File:        CoherentPionAnaCosmic_module.cc
//
// Generated at Tue Jul 18 15:54:13 2017 by Ilker Parmaksiz using artmod
// from cetpkgsupport v1_11_00.
////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <map>
#include "math.h"
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
//#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
///////////////////////////////////////////////////////////////
#include "larcore/Geometry/Geometry.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "lardataobj/MCBase/MCShower.h"
#include "lardataobj/MCBase/MCTrack.h"
#include "lardataobj/MCBase/MCStep.h"
#include "nusimdata/SimulationBase/MCFlux.h"
//////////////////////////////////////////////////
#include "canvas/Persistency/Common/Ptr.h"
#include "canvas/Persistency/Common/PtrVector.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "canvas/Persistency/Common/FindMany.h"
///////////////////////////////////////////////////////
#include "larsim/MCCheater/BackTracker.h"
//////////////////////
///// HISTOGRAM /////
/////////////////////
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "art/Framework/Services/Registry/ServiceHandle.h" 
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/AuxDetSimChannel.h"

/////////////////////////Geometry//////////////////////
#include "larcore/Geometry/GeometryCore.h"

// #####################
// ### ROOT includes ###
// #####################

#include "TComplex.h"
#include "TFile.h"
#include "TH2D.h"
#include "TH3.h"
#include "TF1.h"
#include "TTree.h"
#include "TTimeStamp.h"
#include "TAxis.h"
#include "larcoreobj/SummaryData/POTSummary.h"

// McTrack

#include "nusimdata/SimulationBase/MCTruth.h"
#include "lardataobj/MCBase/MCShower.h"
#include "lardataobj/MCBase/MCTrack.h"
#include "lardataobj/MCBase/MCStep.h"
#include <typeinfo>
#include <stdio.h>    
#define PI 3.14159265
class CoherentPionAnaCosmic;

class CoherentPionAnaCosmic : public art::EDAnalyzer {
public:
  explicit CoherentPionAnaCosmic(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CoherentPionAnaCosmic(CoherentPionAnaCosmic const &) = delete;
  CoherentPionAnaCosmic(CoherentPionAnaCosmic &&) = delete;
  CoherentPionAnaCosmic & operator = (CoherentPionAnaCosmic const &) = delete;
  CoherentPionAnaCosmic & operator = (CoherentPionAnaCosmic &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void WriteToFile(std::map<std::string,int>MCTrack_Particles);
  void VertexAct(std::vector<art::Ptr<sim::SimChannel>>&simList,std::vector<double> & XYZ,double & Etotal);
  void OpenFile();

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run const & r) override;
  void beginSubRun(art::SubRun const & sr) override;
  void endJob() override;
  void endRun(art::Run const & r) override;
  void endSubRun(art::SubRun const & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

  // Declare member data here.
  std::string fCorsikaGenModuleLabel;
  std::string fG4ModuleLabel;
  std::string fLArGeantModuleLabel;
  std::string fMCShowerModuleLabel;
  std::string fMCTrackModuleLabel;
  std::string fPOTModuleLabel;
  std::string fSimChanModuleLabel;
  std::ofstream file;
  //std::map<std::string,int>Total_Events;
  Double_t pdgCode;
  Double_t Distance;
  unsigned int TrackID;
  unsigned int InBound=0;
  unsigned int AllInBound=0;
  unsigned int WMotherInBound=0;
  unsigned int cospart=0;
  
  unsigned int Total_DOCA=0;
  unsigned int Total_Cone=0;
  std::string Process;

  std::vector <std::string> data_variable={"PdgCode=","Vx","Vy","Vz","Ex","Ey","Ez","Px","Py","Pz","E","Distance"}; 
  std::vector <TH1D *> h1D;
  unsigned int closecount=0;
  double Etotal=0;
  unsigned int Total_Vertex=0;
            
  //Float_t Mother_PdgCode; 
  //std::string Mother_Process; 
    

  
};


CoherentPionAnaCosmic::CoherentPionAnaCosmic(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  this->reconfigure(p);
}
void CoherentPionAnaCosmic::OpenFile()
{
  file.open("output.cosmic",std::ofstream::out | std::ofstream::app);
  
}
void CoherentPionAnaCosmic::WriteToFile(std::map<std::string,int>MCTrack_Particles)
{

  //for(auto& i :MCTrack_Particles)
    //file <<i.first<<"="<<i.second<<"\n";
}
void CoherentPionAnaCosmic::VertexAct(std::vector<art::Ptr<sim::SimChannel>>&simList,std::vector<double> & XYZ,double & Etotal)
   {
    // === Geometry Service ===
    art::ServiceHandle<geo::Geometry>geo;
    
    
           
    for(size_t nChan = 0; nChan < simList.size(); nChan++) 
    {
       
     if(simList.at(nChan)->Channel()==geo->NearestChannel(XYZ,2))
     {
       // Get the information of each wire
       const auto & wire = simList.at(nChan)->TDCIDEMap();
       for(auto it=wire.begin();it!=wire.end();it++)
       {
          // Looping over the IDEs in a given time tick
          for(size_t i=0;i<it->second.size();i++)
          {
            //Only non-showering (nonnegative) primary track IDEs
            //if(it->second.at(i).trackID > 13 ) { continue; } 
            
            //TrackID1=it->second.at(i).trackID;
           // std::cout<<TrackID1<<std::endl;
            //std::cout<<"TrackID"<<it->second.at(i).trackID<<std::endl;
            //std::cout<<"Eng: "<<it->second.at(i).energy<<std::endl;
            //std::cout<<"X: "<<it->second.at(i).x<<std::endl;
            //std::cout<<"Y: "<<it->second.at(i).y<<std::endl;
            //std::cout<<"Z: "<<it->second.at(i).z<<std::endl;
            Etotal+=it->second.at(i).energy;
            
           // if(TrackID1!=TrackID2 && i>0)
            
          }
          
         }
        //std::cout<<Etotal<<std::endl;
       }
     }
   }
void CoherentPionAnaCosmic::analyze(art::Event const & evt)
{
  art::Handle< std::vector<sim::MCTrack> > mctrackh;
  evt.getByLabel(fMCTrackModuleLabel, mctrackh);
 
    //For SimChannel  (Vertex Activity)
    art::Handle< std::vector<sim::SimChannel> > SimListHandle; 
    std::vector<art::Ptr<sim::SimChannel> > simList;    
    
    if(evt.getByLabel(fSimChanModuleLabel, SimListHandle))
    { art::fill_ptr_vector(simList, SimListHandle); }
  
 // unsigned int count=0;
  std::map <unsigned int,std::vector <Double_t>> MCTrack_Particles;
  //std::map <unsigned int,std::vector <Double_t>> SameVertex ;
  std::map <unsigned int,std::vector<Double_t>> X;
  std::map <unsigned int,std::vector<Double_t>> Y;
  std::map <unsigned int,std::vector<Double_t>> Z;
  std::map<unsigned int,Double_t> phiangle;
  Etotal=0;
  // looping on mctrack info
  for(std::vector<sim::MCTrack>::const_iterator imctrk = mctrackh->begin();imctrk != mctrackh->end(); ++imctrk) 
  {
      
    const sim::MCTrack& mctrk = *imctrk;
    pdgCode=mctrk.PdgCode();
    TrackID=mctrk.TrackID();
    
     Process=mctrk.Process();           
     
     Distance=sqrt((mctrk.End().X()-mctrk.Start().X())*(mctrk.End().X()-mctrk.Start().X()) + (mctrk.End().Y()-mctrk.Start().Y())*(mctrk
     .End().Y()-mctrk.Start().Y()) + (mctrk.End().Z()-mctrk.Start().Z())*(mctrk.End().Z()-mctrk.Start().Z()));
     std::vector<Double_t> data={pdgCode,mctrk.Start().X(),mctrk.Start().Y(),mctrk.Start().Z(),mctrk.End().X(),mctrk.End().Y(),mctrk.End().Z(),mctrk.Start().Px(),mctrk.Start().Py(),mctrk.Start().Pz(),mctrk.Start().E(),Distance};
     
        std::vector <double> Vertex={data[1],data[2],data[3]};            
        MCTrack_Particles.insert(std::pair<unsigned int,std::vector<Double_t>>(TrackID,data));
      
        
        std::vector<Double_t> XStep;
        std::vector<Double_t> YStep;
        std::vector<Double_t> ZStep;
        //std::vector<Double_t> TStep;
        //std::cout<<"TrackID="<<TrackID<<std::endl;
        for(auto step:mctrk)
        { 
           /*std::cout<<TrackID<<std::endl;
           std::cout<<"X="<<step.X()<<std::endl;
           std::cout<<"Y="<<step.Y()<<std::endl;
           std::cout<<"Z="<<step.Z()<<std::endl;
           */
           
           //if(((step.X()==0 || step.X()==250) && (step.Y()==-125 || step.Y()==125)) || ((step.X()==0 || step.X()==250) && (step.Z()==0 || step.Z()==1030)) || ((step.Y()==-124 || step.Y()==125) && (step.Z()==0 || step.Z()==1030)))
               // InBound+=1;
                
           XStep.push_back(step.X());
           YStep.push_back(step.Y());
           ZStep.push_back(step.Z());
            if((pdgCode!=111 || pdgCode!=2112)){
             std::vector<double> XYZ={step.X(),step.Y(),step.Z()};
          if(abs(XYZ[0]-Vertex[0])<5 && abs(XYZ[1]-Vertex[1])< 5 && abs(XYZ[2]-Vertex[2])<5)
            {
            if((XYZ[0]>=0 && XYZ[0]<=250) && (XYZ[1]>=-125 && XYZ[1]<=125) && (XYZ[2]>=0 && XYZ[2]<=1030)) 
              VertexAct(simList,XYZ,Etotal);
            }
          }
        }
       if(XStep.empty() && YStep.empty() && ZStep.empty())
       { 
        
          if((pdgCode!=111 || pdgCode!=2112)){
            if((Vertex[0]>=0 && Vertex[0]<=250) && (Vertex[1]>=-125 && Vertex[1]<=125) && (Vertex[2]>=0 && Vertex[2]<=1030)) 
              VertexAct(simList,Vertex,Etotal);
          }
            XStep={data[1],data[4]};
            YStep={data[2],data[5]};
            ZStep={data[3],data[6]};
           // if(((data[1]==0 || data[1]==250) && (data[2]==-125 || data[2]==125)) || ((data[1]==0 || data[1]==250) && (data[3]==0 || data[3]==1030)) || ((data[2]==-125 || data[2]==125) && (data[3]==0 || data[3]==1030)))
             //   InBound+=1;
       }         


       X.insert(std::pair<unsigned int,std::vector<Double_t>>(TrackID,XStep));
       Y.insert(std::pair<unsigned int,std::vector<Double_t>>(TrackID,YStep));
       Z.insert(std::pair<unsigned int,std::vector<Double_t>>(TrackID,ZStep));
         
    
  }
  h1D[3]->Fill(Etotal);
  //std::cout<<"Ene "<<Etotal<<std::endl;
  Total_Vertex=Total_Vertex+1;
   //std::cout <<"Size="<<MCTrack_Particles.size()<<std::endl;

   for(auto i=MCTrack_Particles.begin();i!=MCTrack_Particles.end();++i)
   {
        //std::vector <Double_t> Vertex;
        //unsigned int TrackID=i->first;
        //auto it2=data_variable.begin();
    
        unsigned int sizet;
        unsigned int count=0;
        int Xcomp,Ycomp,Zcomp;
        
        //any calculations for two particles
        for(auto s=std::next(i,1);s!=MCTrack_Particles.end();++s)
        {   
            if((MCTrack_Particles.size()>1) && ((float)i->second[1]==(float)s->second[1] &&  (float)i->second[2]==(float)s->second[2] && (float)i->second[3]==(float)s->second[3]) && ((float)i->second[1]!=(float)i->second[4] && (float)i->second[2]!=(float)i->second[5] && (float)i->second[3]!=(float)i->second[5]))
            {    
                Double_t phi,philength;
                if(count==0)
                {
                     philength=(sqrt(pow(i->second[7],2) + pow(i->second[8],2) + pow(i->second[9],2))*sqrt(pow(1,2)));
                     phi=(acos((i->second[9]*1)/philength) * 180/PI);
                     //std::cout<<"Track ID="<<i->first<<std::endl;
                    // std::cout<<"Phi(i)="<<phi<<std::endl;
                     phiangle.insert(std::pair<unsigned int,Double_t>(i->first,phi));
                     count+=1;
                }
                philength=(sqrt(pow(s->second[7],2) + pow(s->second[8],2) + pow(s->second[9],2))*sqrt(pow(1,2)));
                phi=(acos((s->second[9]*1)/philength) * 180/PI);
                phiangle.insert(std::pair<unsigned int,Double_t>(s->first,phi));
                  
                /*std::cout<<"-----Track i----"<<i->first<<std::endl;
                for(auto l=i->second.begin();l!=i->second.end();++l)
                    std::cout<<*l<<std::endl;
                std::cout<<"-----Track s----"<<s->first<<std::endl;
                for(auto l=s->second.begin();l!=s->second.end();++l)
                    std::cout<<*l<<std::endl;
                */
                Double_t theta,thetalength,newAngle,newAnglelength;                  
                thetalength=(sqrt(pow(i->second[7],2) + pow(i->second[8],2) + pow(i->second[9],2))*(sqrt(pow(s->second[7],2) + pow(s->second[8],2) + pow(s->second[9],2))));
                
             
            
                auto x1=X.find(i->first);
                auto y1=Y.find(i->first);
                auto z1=Z.find(i->first);
            
                auto x2=X.find(s->first);
                auto y2=Y.find(s->first);
                auto z2=Z.find(s->first);
                
                if(x1!=X.end() && x2!=X.end() && y1!=Y.end() && y2!=Y.end() && z1!=Z.end() && z2!=Z.end())
                {   

                    (x1->second.size()<x2->second.size()) ? sizet=x1->second.size():sizet=x2->second.size();

                    //std::cout <<"sizet="<<sizet<<std::endl;
                    Double_t closest=9999;
                      
                                                    
                        for(unsigned int t=sizet;t>0;--t)
                        {
     
                            
                            if(x1->second[t]!=x2->second[t] && y1->second[t]!=y2->second[t] && z1->second[t]!=z2->second[t])
                            {
                                Double_t Result=sqrt(pow(x1->second[t]-x2->second[t],2)+pow(y1->second[t]-y2->second[t],2) + pow(z1->second[t]-z2->second[t],2));
                                //std::cout<<"Result="<<Result<<std::endl;
                                if(Result<closest)
                                    closest=Result;       
                            }
                        }
                        //std::cout<<"closest="<<closest<<std::endl;
                        if (closest<10){
                            closecount+=1;
                            //h1D[3]->Fill(i->second[0]);
                            //h1D[3]->Fill(s->second[0]);
                            //std::cout<<"i="<<i->first<<"s="<<s->first<<std::endl;
                            if(thetalength!=0)
                            {   
                                Xcomp=i->second[7]+s->second[7];
                                Ycomp=i->second[8]+s->second[8];
                                Zcomp=i->second[9]+s->second[9];
                                newAnglelength=(sqrt(pow(Xcomp,2) + pow(Ycomp,2) + pow(Zcomp,2)));
                                newAngle=(acos(Zcomp/newAnglelength)* 180/PI);
                                
                                h1D[0]->Fill(newAngle);
                                theta=(acos((i->second[7]*s->second[7] + i->second[8]*s->second[8] + i->second[9]*s->second[9])/thetalength) * 180/PI); 
                                h1D[1]->Fill(theta);
                                Total_Cone=Total_Cone+1;
                                
                              
                            }
                         }
                         //std::cout<<"closest="<<closest<<std::endl;
                        if(closest!=9999){   
                            h1D[2]->Fill(closest);
                            Total_DOCA=Total_DOCA+1;
                         }
                        
                               
                        
                        
                        
                        
                     
                }
            }
           
         } 
   }
   
   /*for(auto i=phiangle.begin();i!=phiangle.end();++i)
       h1D[2]->Fill(i->second);
  */
  
}

void CoherentPionAnaCosmic::beginJob()
{

      //Setting Variables for histograms
       
      
      std::vector<const char *>h1D_title={"ConeAngle","Angle Between two tracks","Distance of Closest Approach","Vertex Activity"};
      std::vector<const char *>h1D_name={"ConeAngle_cosmic","MudotPi_cosmic","DOCA_cosmic","VertexAct_Cosmic"};
      std::vector <const char *> h1D_Xaxis={"Cone Angle [Degrees]","Angle [Degrees]","DOCA [cm]","Energy[MeV]"};
      std::vector<std::vector<int>> h1D_binds={{720,-360,360},{720,-360,360},{1000,0,1000},{10000,0,10000}};
      art::ServiceHandle<art::TFileService> tfs;
      for(unsigned int k=0;(k<h1D_name.size());++k)
      {

        h1D.push_back(tfs->make<TH1D>(h1D_name[k],h1D_title[k],h1D_binds[k][0],h1D_binds[k][1],h1D_binds[k][2]));
        h1D[k]->GetYaxis()->SetTitle("Number of Events");
        h1D[k]->GetXaxis()->SetTitle(h1D_Xaxis[k]);
      }
}

void CoherentPionAnaCosmic::beginRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void CoherentPionAnaCosmic::beginSubRun(art::SubRun const & sr)
{
  
}

void CoherentPionAnaCosmic::endJob()
{

    //Printing results
    
    /*std::cout << "DOCA is less than 10 cm count<>"<< closecount<<std::endl;
    std::cout << "In Bound<>"<< InBound<<std::endl;
    std::cout << "Cosmic Particles in Vertex<>"<< cospart<<std::endl;
    std::cout << "With Mother<>"<< WMotherInBound<<std::endl;  
    std::cout << "All In Bound<>"<< AllInBound<<std::endl;  
    */
      
    std::cout <<"Total_Cone"<<"<>"<< Total_Cone<<std::endl;
    std::cout <<"Total_DOCA"<<"<>"<< Total_DOCA<<std::endl;
    std::cout <<"Total_Vertex"<<"<>"<< Total_Vertex<<std::endl;
    
}

void CoherentPionAnaCosmic::endRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void CoherentPionAnaCosmic::endSubRun(art::SubRun const & sr)
{
  /*double pot;
  art::Handle< sumdata::POTSummary > potListHandle;
  if(sr.getByLabel(fPOTModuleLabel,potListHandle))
    pot=potListHandle->totpot;
  
    
  std::cout <<"POT="<<pot<<"\n";
  */

}

void CoherentPionAnaCosmic::reconfigure(fhicl::ParameterSet const & p)
{
  fCorsikaGenModuleLabel = p.get < std::string >("CorsikaGenModuleLabel");
  fG4ModuleLabel = p.get < std::string >("G4ModuleLabel");
  fLArGeantModuleLabel = p.get < std::string >("LArGeantModuleLabel");
  fMCShowerModuleLabel= p.get < std::string >("MCShowerModuleLabel");
  fMCTrackModuleLabel= p.get < std::string >("MCTrackModuleLabel");
  fPOTModuleLabel =p.get < std::string >("POTModuleLabel");
  fSimChanModuleLabel =p.get < std::string >("SimChanModuleLabel");
}

void CoherentPionAnaCosmic::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void CoherentPionAnaCosmic::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void CoherentPionAnaCosmic::respondToOpenInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void CoherentPionAnaCosmic::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(CoherentPionAnaCosmic)
